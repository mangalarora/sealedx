/*
 * Designed and developed by 2022 skydoves (Jaewoong Eum)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.skydoves.sealedx.processor.proguards

import com.google.devtools.ksp.symbol.ClassKind
import com.squareup.kotlinpoet.ClassName

/**
 * @author skydoves (Jaewoong Eum)
 * @since 1.0.0
 *
 * https://github.com/ZacSweers/MoshiX/blob/ecacd5858d40771f2178dbcf293fd53333d11152/moshi-sealed/codegen/src/main/kotlin/dev/zacsweers/moshix/sealed/codegen/ProguardConfig.kt
 *
 * Represents a proguard configuration for a given spec. This covers two main areas:
 * - Keeping the target class or interface name to SealedX's reflective lookup of the sealed classes and interfaces.
 * - Keeping the generated sealed class or interface name + public constructor for reflective lookup.
 *
 * Each rule is intended to be as specific and targeted as possible to reduce footprint, and each is
 * conditioned on usage of the original target type.
 */
internal data class ProguardConfig(
  val targetClass: ClassName,
  val targetClassKind: ClassKind,
  val extensiveName: String,
  val extensiveConstructorParams: List<String>
) {
  internal val outputFile =
    "META-INF/proguard/sealedx-${targetClass.canonicalName}-$extensiveName.pro"
  private val targetType = targetClassKind.type

  internal fun writeTo(out: Appendable): Unit =
    out.run {
      appendLine(
        "# This file was generated by sealedx (https://github.com/skydoves/sealedx). \n" +
          "# Do not modify this file."
      )
      //
      // -if class {the target class}
      // -keepnames class {the target class}
      // -if class {the target class}
      // -keep class {the generated sealed extensive class} {
      //    <init>(...);
      // }
      //
      val targetName = targetClass.reflectionName()
      val sealedExtensiveCanonicalName =
        ClassName(targetClass.packageName, extensiveName).canonicalName
      // Keep the class or interface name for SealedX's reflective lookup based on it
      appendLine("-if $targetType $targetName")
      appendLine("-keepnames $targetType $targetName")

      appendLine("-if $targetType $targetName")
      appendLine("-keep $targetType $sealedExtensiveCanonicalName {")
      // Keep the constructor for SealedX's reflective lookup
      val constructorArgs = extensiveConstructorParams.joinToString(",")
      appendLine("    public <init>($constructorArgs);")
      appendLine("}")
    }
}
